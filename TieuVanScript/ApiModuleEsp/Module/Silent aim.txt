local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local CONFIG = {
	Enabled = false,
	FOVSize = 150,
	MaxRange = 5000,
	TeamCheck = true,
	WallCheck = true,
	AimPart = "Head",
	PredictionEnabled = true,
	PredictionFactor = 0.165,
	OffsetY = 0,
	FOVOffsetY = 0,
	LockTarget = true,
	HitChance = 100,
	TargetMode = "NPCs", -- "NPCs", "Players", "Both"
	AggressiveNPCDetection = false,
	DebugNPCs = false,
	FOVColor = Color3.fromRGB(0, 255, 0),
}

local LockedTarget = nil
local LastTargetCheck = 0
local TARGET_CHECK_INTERVAL = 0.1
local VelocityCache = {}
local LastCacheUpdate = 0
local CacheUpdateInterval = 1
local NPCCache = {}
local PlayerCache = {}

--// NPC TAGS
local NPCTags = {
	"NPC", "Npc", "npc", "Enemy", "enemy", "Enemies", "enemies",
	"Hostile", "hostile", "Bad", "bad", "BadGuy", "badguy",
	"Foe", "foe", "Opponent", "opponent", "Bot", "bot", "Bots", "bots",
	"Mob", "mob", "Mobs", "mobs", "Monster", "monster", "Monsters", "monsters",
	"Zombie", "zombie", "Zombies", "zombies", "Creature", "creature",
	"Animal", "animal", "Beast", "beast", "Villain", "villain",
	"Boss", "boss", "MiniBoss", "miniboss", "Guard", "guard",
	"Guardian", "guardian", "Soldier", "soldier", "Warrior", "warrior",
	"Fighter", "fighter", "Target", "target", "Dummy", "dummy",
	"Dummies", "dummies", "Skeleton", "skeleton", "Orc", "orc",
	"Goblin", "goblin", "Robot", "robot", "Drone", "drone"
}

--=============================================================================
-- UTILITY FUNCTIONS
--=============================================================================

local function GetCharacter(player)
	return player and player.Character
end

local function GetCharacterPart(player, partName)
	if not partName then return nil end
	local char = GetCharacter(player)
	return char and char:FindFirstChild(partName)
end

local function GetHumanoid(player)
	local char = GetCharacter(player)
	return char and (char:FindFirstChild("Humanoid") or char:FindFirstChildOfClass("Humanoid"))
end

local function GetLocalHRP()
	return GetCharacterPart(LocalPlayer, "HumanoidRootPart")
end

local function GetTargetPart(character)
	if CONFIG.AimPart == "Head" then
		return character:FindFirstChild("Head")
	elseif CONFIG.AimPart == "Torso" or CONFIG.AimPart == "UpperTorso" then
		return character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
	elseif CONFIG.AimPart == "LowerTorso" then
		return character:FindFirstChild("LowerTorso") or character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
	end
	return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head")
end

local function GetScreenPosition(position)
	local screenPos, onScreen = Camera:WorldToScreenPoint(position)
	return Vector2.new(screenPos.X, screenPos.Y), onScreen, screenPos.Z
end

local function GetScreenCenter()
	return Vector2.new(Camera.ViewportSize.X / 2.0, Camera.ViewportSize.Y / 2.0 + CONFIG.FOVOffsetY)
end

local function GetAngularDistance(position)
	local camPos = Camera.CFrame.Position
	local camLook = Camera.CFrame.LookVector
	local toTarget = (position - camPos).Unit
	
	local dot = camLook:Dot(toTarget)
	dot = math.clamp(dot, -1, 1)
	local angle = math.acos(dot)
	local angleDegrees = math.deg(angle)
	
	return angleDegrees
end

local function GetFOVAngleFromPixels()
	local viewportSize = Camera.ViewportSize
	local halfFOV = math.rad(Camera.FieldOfView / 2)
	local pixelsPerDegree = (viewportSize.Y / 2) / math.deg(halfFOV)
	return CONFIG.FOVSize / pixelsPerDegree
end

local function IsVisibleTarget(character)
	if not CONFIG.WallCheck then return true end
	
	local targetPart = GetTargetPart(character)
	if not targetPart then return false end
	
	local origin = Camera.CFrame.Position
	local targetPos = targetPart.Position
	local direction = targetPos - origin
	local distance = direction.Magnitude
	
	if distance < 1 then return true end
	
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Exclude
	rayParams.FilterDescendantsInstances = {GetCharacter(LocalPlayer), character}
	rayParams.IgnoreWater = true
	
	local result = Workspace:Raycast(origin, direction.Unit * (distance - 1), rayParams)
	return result == nil
end

--=============================================================================
-- NPC DETECTION
--=============================================================================

local function IsPlayer(character)
	if not character or not character:IsA("Model") then return false end
	if character == LocalPlayer.Character then return true end
	local player = Players:GetPlayerFromCharacter(character)
	return player ~= nil
end

local function IsNPC(character)
	if not character or not character:IsA("Model") then return false end
	if IsPlayer(character) then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local head = character:FindFirstChild("Head")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	
	if not humanoid or not head or not hrp or humanoid.Health <= 0 then
		return false
	end
	
	if CONFIG.AggressiveNPCDetection then return true end
	
	local charName = character.Name:lower()
	for _, tag in pairs(NPCTags) do
		if charName:find(tag:lower(), 1, true) then return true end
	end
	
	local npcFolders = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Enemy", "Hostile", "Monsters"}
	for _, folderName in pairs(npcFolders) do
		local folder = Workspace:FindFirstChild(folderName)
		if folder and character:IsDescendantOf(folder) then return true end
	end
	
	return true
end

local function FindNPCsRecursive(parent)
	local foundNPCs = {}
	for _, child in pairs(parent:GetChildren()) do
		if child:IsA("Model") and IsNPC(child) then
			table.insert(foundNPCs, child)
		end
		if not child:IsA("BasePart") then
			local subNPCs = FindNPCsRecursive(child)
			for _, npc in pairs(subNPCs) do
				table.insert(foundNPCs, npc)
			end
		end
	end
	return foundNPCs
end

local function UpdateNPCCache()
	local currentTime = tick()
	if currentTime - LastCacheUpdate < CacheUpdateInterval then return end
	
	LastCacheUpdate = currentTime
	NPCCache = {}
	PlayerCache = {}
	
	local allModels = {}
	for _, model in pairs(Workspace:GetChildren()) do
		if model:IsA("Model") and model ~= LocalPlayer.Character then
			table.insert(allModels, model)
		end
	end
	
	local npcFolders = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Characters", "Spawns", "Monsters"}
	for _, folderName in pairs(npcFolders) do
		local folder = Workspace:FindFirstChild(folderName)
		if folder then
			local npcsInFolder = FindNPCsRecursive(folder)
			for _, npc in pairs(npcsInFolder) do
				table.insert(allModels, npc)
			end
		end
	end
	
	for _, model in pairs(allModels) do
		local hrp = model:FindFirstChild("HumanoidRootPart")
		local humanoid = model:FindFirstChildOfClass("Humanoid")
		
		if hrp and humanoid and humanoid.Health > 0 then
			if IsPlayer(model) then
				local player = Players:GetPlayerFromCharacter(model)
				PlayerCache[model] = {Model = model, HRP = hrp, Humanoid = humanoid, Player = player, IsNPC = false}
			elseif IsNPC(model) then
				NPCCache[model] = {Model = model, HRP = hrp, Humanoid = humanoid, IsNPC = true}
			end
		end
	end
	
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local char = player.Character
			local hrp = char:FindFirstChild("HumanoidRootPart")
			local humanoid = char:FindFirstChildOfClass("Humanoid")
			if hrp and humanoid and humanoid.Health > 0 then
				PlayerCache[char] = {Model = char, HRP = hrp, Humanoid = humanoid, Player = player, IsNPC = false}
			end
		end
	end
end

--=============================================================================
-- VELOCITY & PREDICTION
--=============================================================================

local function CalculateVelocity(character, currentPos)
	local cache = VelocityCache[character]
	local now = tick()
	
	if not cache then
		VelocityCache[character] = {
			Position = currentPos,
			Time = now,
			Velocity = Vector3.zero
		}
		return Vector3.zero
	end
	
	local deltaTime = now - cache.Time
	if deltaTime < 0.016 then
		return cache.Velocity
	end
	
	local velocity = (currentPos - cache.Position) / deltaTime
	
	VelocityCache[character] = {
		Position = currentPos,
		Time = now,
		Velocity = velocity
	}
	
	return velocity
end

local function PredictPosition(character, targetPart)
	if not CONFIG.PredictionEnabled then return targetPart.Position end
	if not targetPart then return targetPart.Position end
	
	local currentPos = targetPart.Position
	local hrp = character:FindFirstChild("HumanoidRootPart")
	local velocity = hrp and hrp.Velocity or Vector3.zero
	
	return currentPos + velocity * CONFIG.PredictionFactor
end

--=============================================================================
-- TARGET SELECTION
--=============================================================================

local function IsValidTarget(character, skipFOVCheck)
	if not character or character == LocalPlayer.Character then return false end
	if not character:IsDescendantOf(Workspace) then return false end
	
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp then return false end
	
	local hum = character:FindFirstChildOfClass("Humanoid")
	if not hum or hum.Health <= 0 then return false end
	
	local localHRP = GetLocalHRP()
	if not localHRP then return false end
	
	local targetPart = GetTargetPart(character)
	if not targetPart then return false end
	
	-- Check if NPC or Player
	local isNPC = IsNPC(character)
	local isPlayer = IsPlayer(character)
	
	-- Check target mode
	if CONFIG.TargetMode == "NPCs" and not isNPC then return false end
	if CONFIG.TargetMode == "Players" and not isPlayer then return false end
	
	-- Team check for players
	if isPlayer then
		if CONFIG.TeamCheck then
			local player = Players:GetPlayerFromCharacter(character)
			if player and player.Team and LocalPlayer.Team and player.Team == LocalPlayer.Team then
				return false
			end
		end
	end
	
	-- Range check
	local worldDist = (targetPart.Position - localHRP.Position).Magnitude
	if worldDist > CONFIG.MaxRange then return false end
	
	-- FOV check
	if not skipFOVCheck then
		local angularDist = GetAngularDistance(targetPart.Position)
		local fovAngle = GetFOVAngleFromPixels()
		if angularDist > fovAngle then return false end
	end
	
	-- Wall check
	if CONFIG.WallCheck and not IsVisibleTarget(character) then
		return false
	end
	
	return true
end

local function GetClosestTarget()
	UpdateNPCCache()
	
	local bestTarget = nil
	local bestDistance = math.huge
	
	-- Check NPCs
	if CONFIG.TargetMode == "NPCs" or CONFIG.TargetMode == "Both" then
		for character, _ in pairs(NPCCache) do
			if IsValidTarget(character, false) then
				local targetPart = GetTargetPart(character)
				if targetPart then
					local angularDist = GetAngularDistance(targetPart.Position)
					if angularDist < bestDistance then
						bestTarget = character
						bestDistance = angularDist
					end
				end
			end
		end
	end
	
	-- Check Players
	if CONFIG.TargetMode == "Players" or CONFIG.TargetMode == "Both" then
		for character, _ in pairs(PlayerCache) do
			if IsValidTarget(character, false) then
				local targetPart = GetTargetPart(character)
				if targetPart then
					local angularDist = GetAngularDistance(targetPart.Position)
					if angularDist < bestDistance then
						bestTarget = character
						bestDistance = angularDist
					end
				end
			end
		end
	end
	
	return bestTarget
end

local function ShouldSwitchTarget()
	if not CONFIG.LockTarget then return true end
	if not LockedTarget then return true end
	
	if not IsValidTarget(LockedTarget, true) then
		return true
	end
	
	local targetPart = GetTargetPart(LockedTarget)
	if targetPart then
		local angularDist = GetAngularDistance(targetPart.Position)
		local fovAngle = GetFOVAngleFromPixels()
		
		if angularDist > fovAngle * 2 then
			return true
		end
	end
	
	return false
end

--=============================================================================
-- SILENT AIM HOOKS
--=============================================================================

local function ShouldHit()
	if CONFIG.HitChance >= 100 then return true end
	if CONFIG.HitChance <= 0 then return false end
	return math.random(1, 100) <= CONFIG.HitChance
end

local oldNamecall = nil
if not oldNamecall then
	oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
		if not CONFIG.Enabled or not LockedTarget then
			return oldNamecall(self, ...)
		end
		
		local targetPart = GetTargetPart(LockedTarget)
		if not targetPart then return oldNamecall(self, ...) end
		
		local method = getnamecallmethod()
		local args = {...}
		
		if (method == "FireServer" or method == "InvokeServer") and typeof(self) == "Instance" then
			local selfName = self.Name:lower()
			if string.find(selfName, "fire") or string.find(selfName, "hit") or string.find(selfName, "attack") or string.find(selfName, "damage") then
				if not ShouldHit() then return oldNamecall(self, ...) end
				
				local newArgs = {}
				local modified = false
				
				for i, arg in pairs(args) do
					if typeof(arg) == "Vector3" then
						newArgs[i] = targetPart.Position
						modified = true
					elseif typeof(arg) == "CFrame" then
						newArgs[i] = CFrame.new(targetPart.Position)
						modified = true
					elseif typeof(arg) == "Ray" then
						local origin = arg.Origin
						newArgs[i] = Ray.new(origin, (targetPart.Position - origin).Unit * 100)
						modified = true
					else
						newArgs[i] = arg
					end
				end
				
				if modified then return oldNamecall(self, unpack(newArgs)) end
			end
		end
		
		if method == "Raycast" and self == Workspace then
			local origin = args[1]
			local direction = args[2]
			
			if origin and targetPart then
				if not ShouldHit() then return oldNamecall(self, ...) end
				local newDir = (targetPart.Position - origin).Unit * direction.Magnitude
				return oldNamecall(self, origin, newDir, args[3], args[4])
			end
		end
		
		return oldNamecall(self, ...)
	end)
end

--=============================================================================
-- FOV CIRCLE
--=============================================================================

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Radius = CONFIG.FOVSize
fovCircle.Filled = false
fovCircle.Visible = false
fovCircle.ZIndex = 999
fovCircle.Color = CONFIG.FOVColor

--=============================================================================
-- RENDER LOOP
--=============================================================================

RunService.RenderStepped:Connect(function()
	if not CONFIG.Enabled then
		LockedTarget = nil
		return
	end
	
	local now = tick()
	
	if now - LastTargetCheck > TARGET_CHECK_INTERVAL then
		LastTargetCheck = now
		
		if ShouldSwitchTarget() then
			LockedTarget = GetClosestTarget()
		end
	end
	
	-- Update FOV circle
	local center = GetScreenCenter()
	fovCircle.Position = center
	fovCircle.Visible = CONFIG.Enabled
	fovCircle.Radius = CONFIG.FOVSize
	fovCircle.Color = CONFIG.FOVColor
end)

Players.PlayerRemoving:Connect(function(player)
	for char, _ in pairs(PlayerCache) do
		if Players:GetPlayerFromCharacter(char) == player then
			PlayerCache[char] = nil
			VelocityCache[char] = nil
			if LockedTarget == char then
				LockedTarget = nil
			end
		end
	end
end)

--=============================================================================
-- PUBLIC API
--=============================================================================

local SilentAimAPI = {}

function SilentAimAPI:UpdateConfig(newConfig)
	for key, value in pairs(newConfig) do
		if CONFIG[key] ~= nil then
			CONFIG[key] = value
		end
	end
end

function SilentAimAPI:GetConfig()
	return CONFIG
end

function SilentAimAPI:Toggle(state)
	CONFIG.Enabled = state
	if not state then
		LockedTarget = nil
	end
end

function SilentAimAPI:Destroy()
	fovCircle:Remove()
	VelocityCache = {}
	LockedTarget = nil
end

return SilentAimAPI
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local CONFIG = {
	SilentAim = true,
	FOV = 150,
	FOVColor = Color3.fromRGB(255, 255, 255),
	VisibleCheck = true,
	TeamCheck = false,
	TeamCheckForNPCs = false,
	Prediction = 0.165,
	UpdateRate = 0.1,
	TargetMode = "Players",
	AimPart = "Head",
	HitChance = 100,
	BulletTeleport = false,
	DebugNPCs = false,
	AggressiveNPCDetection = false,
	TargetPriority = "Crosshair",
	StickyAim = true,
}

local CurrentTarget = nil
local TargetPart = nil
local TargetInRange = false
local NPCCache = {}
local PlayerCache = {}
local LastCacheUpdate = 0
local CacheUpdateInterval = 2

local oldNamecall = nil
local oldIndex = nil

local NPCTags = {
	"NPC", "Npc", "npc", "Enemy", "enemy", "Enemies", "enemies",
	"Hostile", "hostile", "Bad", "bad", "BadGuy", "badguy",
	"Foe", "foe", "Opponent", "opponent", "Bot", "bot", "Bots", "bots",
	"Mob", "mob", "Mobs", "mobs", "Monster", "monster", "Monsters", "monsters",
	"Zombie", "zombie", "Zombies", "zombies", "Creature", "creature",
	"Animal", "animal", "Beast", "beast", "Villain", "villain",
	"Boss", "boss", "MiniBoss", "miniboss", "Guard", "guard",
	"Guardian", "guardian", "Soldier", "soldier", "Warrior", "warrior",
	"Fighter", "fighter", "Target", "target", "Dummy", "dummy",
	"Dummies", "dummies", "Skeleton", "skeleton", "Orc", "orc",
	"Goblin", "goblin", "Robot", "robot", "Drone", "drone",
	"Android", "android", "Cyborg", "cyborg", "Automaton", "automaton",
	"Servant", "servant", "Minion", "minion", "Slave", "slave", "Pawn", "pawn",
	"AI", "ai", "A.I.", "Char", "char", "Character", "character",
	"Model", "model", "Event", "event", "Special", "special",
}

--=============================================================================
-- UTILITY FUNCTIONS
--=============================================================================

local function IsPlayer(character)
	if not character or not character:IsA("Model") then return false end
	if character == LocalPlayer.Character then return true end
	local player = Players:GetPlayerFromCharacter(character)
	return player ~= nil
end

local function IsNPC(character)
	if not character or not character:IsA("Model") then return false end
	if IsPlayer(character) then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local head = character:FindFirstChild("Head")
	local hrp = character:FindFirstChild("HumanoidRootPart")
	
	if not humanoid or not head or not hrp or humanoid.Health <= 0 then return false end
	
	if CONFIG.AggressiveNPCDetection then return true end
	
	local charName = character.Name:lower()
	for _, tag in pairs(NPCTags) do
		if charName:find(tag:lower(), 1, true) then return true end
	end
	
	local npcFolders = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Enemy", "Hostile",
		"Monsters", "Zombies", "Creatures", "Characters", "Spawns", "EnemySpawns", "NPCSpawns", "Bosses", "Minions"}
	
	for _, folderName in pairs(npcFolders) do
		local folder = workspace:FindFirstChild(folderName)
		if folder and character:IsDescendantOf(folder) then return true end
	end
	
	return true
end

local function FindNPCsInWorkspaceRecursive(parent)
	local foundNPCs = {}
	for _, child in pairs(parent:GetChildren()) do
		if child:IsA("Model") and IsNPC(child) then
			table.insert(foundNPCs, child)
		end
		if not child:IsA("BasePart") and not child:IsA("Decal") and not child:IsA("Texture") then
			local subNPCs = FindNPCsInWorkspaceRecursive(child)
			for _, npc in pairs(subNPCs) do
				table.insert(foundNPCs, npc)
			end
		end
	end
	return foundNPCs
end

local function IsEnemyPlayer(player)
	if not CONFIG.TeamCheck then return true end
	if not player then return false end
	if not LocalPlayer.Team or not player.Team then return true end
	return LocalPlayer.Team ~= player.Team
end

local function IsEnemyNPC(npcModel)
	if not CONFIG.TeamCheckForNPCs then return true end
	local npcTeamValue = npcModel:FindFirstChild("Team")
	if npcTeamValue and npcTeamValue:IsA("StringValue") then
		local npcTeam = npcTeamValue.Value
		local localTeam = LocalPlayer.Team and LocalPlayer.Team.Name or ""
		if npcTeam and localTeam and npcTeam ~= localTeam then return true end
	end
	local isEnemy = npcModel:FindFirstChild("IsEnemy")
	if isEnemy and isEnemy:IsA("BoolValue") and isEnemy.Value == true then return true end
	return true
end

local function GetTargetPart(character)
	if CONFIG.AimPart == "Head" then
		return character:FindFirstChild("Head")
	elseif CONFIG.AimPart == "Torso" then
		return character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso") or character:FindFirstChild("HumanoidRootPart")
	end
	return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head")
end

--=============================================================================
-- CACHE & VALIDATION
--=============================================================================

local function UpdateCaches()
	local currentTime = tick()
	if currentTime - LastCacheUpdate < CacheUpdateInterval then return end
	LastCacheUpdate = currentTime
	
	NPCCache = {}
	PlayerCache = {}
	
	local allModels = {}
	for _, model in pairs(workspace:GetChildren()) do
		if model:IsA("Model") and model ~= LocalPlayer.Character then
			table.insert(allModels, model)
		end
	end
	
	local npcFolders = {"NPCs", "Enemies", "Bots", "Mobs", "Targets", "Characters", "Spawns", "Monsters"}
	for _, folderName in pairs(npcFolders) do
		local folder = workspace:FindFirstChild(folderName)
		if folder then
			local npcsInFolder = FindNPCsInWorkspaceRecursive(folder)
			for _, npc in pairs(npcsInFolder) do
				table.insert(allModels, npc)
			end
		end
	end
	
	for _, model in pairs(allModels) do
		local hrp = model:FindFirstChild("HumanoidRootPart")
		local humanoid = model:FindFirstChildOfClass("Humanoid")
		
		if hrp and humanoid and humanoid.Health > 0 then
			if IsPlayer(model) then
				PlayerCache[model] = {Model = model, HRP = hrp, Humanoid = humanoid, Player = Players:GetPlayerFromCharacter(model), IsNPC = false}
			elseif IsNPC(model) then
				NPCCache[model] = {Model = model, HRP = hrp, Humanoid = humanoid, IsNPC = true}
			end
		end
	end
	
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local char = player.Character
			local hrp = char:FindFirstChild("HumanoidRootPart")
			local humanoid = char:FindFirstChildOfClass("Humanoid")
			if hrp and humanoid and humanoid.Health > 0 then
				PlayerCache[char] = {Model = char, HRP = hrp, Humanoid = humanoid, Player = player, IsNPC = false}
			end
		end
	end
end

local function ValidateCurrentTarget()
	if not CurrentTarget or not TargetPart then return false end
	local humanoid = CurrentTarget:FindFirstChildOfClass("Humanoid")
	local hrp = CurrentTarget:FindFirstChild("HumanoidRootPart")
	if not humanoid or humanoid.Health <= 0 or not hrp then return false end
	
	local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
	local targetPos = TargetPart.Position
	local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
	if not onScreen then return false end
	
	local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
	local dist = (screenPoint - screenCenter).Magnitude
	if dist > CONFIG.FOV then return false end
	
	if CONFIG.VisibleCheck then
		local raycastParams = RaycastParams.new()
		raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
		raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
		raycastParams.IgnoreWater = true
		
		local origin = Camera.CFrame.Position
		local direction = (targetPos - origin).Unit * (targetPos - origin).Magnitude
		local ray = workspace:Raycast(origin, direction, raycastParams)
		if ray and not ray.Instance:IsDescendantOf(CurrentTarget) then return false end
	end
	return true
end

--=============================================================================
-- TARGET SELECTION
--=============================================================================

local function GetTarget()
	if not LocalPlayer.Character then 
		TargetInRange = false
		TargetPart = nil
		return nil 
	end
	
	UpdateCaches()
	
	if CONFIG.StickyAim and CurrentTarget then
		if ValidateCurrentTarget() then
			TargetInRange = true
			return CurrentTarget
		else
			CurrentTarget = nil
			TargetPart = nil
		end
	end
	
	local bestScore = math.huge
	local closestPart = nil
	local closestTarget = nil
	local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
	local localChar = LocalPlayer.Character
	local localRoot = localChar:FindFirstChild("HumanoidRootPart")
	
	TargetInRange = false
	TargetPart = nil
	if not localRoot then return nil end
	
	local function ProcessTarget(data, isPlayer)
		local hrp = data.HRP
		local humanoid = data.Humanoid
		
		if hrp and humanoid and humanoid.Health > 0 then
			if isPlayer then
				if not IsEnemyPlayer(data.Player) then return end
			else
				if not IsEnemyNPC(data.Model) then return end
			end
			
			local targetPart = GetTargetPart(data.Model)
			if not targetPart then targetPart = hrp end
			
			local targetPos = targetPart.Position
			if hrp.Velocity.Magnitude > 1 and CONFIG.Prediction > 0 then
				targetPos = targetPos + (hrp.Velocity * CONFIG.Prediction)
			end
			
			local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
			if onScreen then
				local screenPoint = Vector2.new(screenPos.X, screenPos.Y)
				local distFromCenter = (screenPoint - screenCenter).Magnitude
				
				if distFromCenter <= CONFIG.FOV then
					local isVisible = true
					
					if CONFIG.VisibleCheck then
						local raycastParams = RaycastParams.new()
						raycastParams.FilterDescendantsInstances = {localChar, Camera}
						raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
						raycastParams.IgnoreWater = true
						
						local origin = Camera.CFrame.Position
						local direction = (targetPos - origin).Unit * (targetPos - origin).Magnitude
						local ray = workspace:Raycast(origin, direction, raycastParams)
						
						if ray and not ray.Instance:IsDescendantOf(data.Model) then isVisible = false end
					end
					
					TargetInRange = true
					
					if isVisible or not CONFIG.VisibleCheck then
						local currentScore = 0
						if CONFIG.TargetPriority == "Crosshair" then
							currentScore = distFromCenter
						elseif CONFIG.TargetPriority == "Distance" then
							currentScore = (targetPos - localRoot.Position).Magnitude
						elseif CONFIG.TargetPriority == "LowestHP" then
							currentScore = humanoid.Health
						else
							currentScore = distFromCenter
						end
						
						if currentScore < bestScore then
							bestScore = currentScore
							closestPart = targetPart
							closestTarget = data.Model
						end
					end
				end
			end
		end
	end
	
	if CONFIG.TargetMode == "NPCs" or CONFIG.TargetMode == "Both" then
		for _, data in pairs(NPCCache) do ProcessTarget(data, false) end
	end
	
	if CONFIG.TargetMode == "Players" or CONFIG.TargetMode == "Both" then
		for _, data in pairs(PlayerCache) do ProcessTarget(data, true) end
	end
	
	TargetPart = closestPart
	return closestTarget
end

--=============================================================================
-- FOV CIRCLE
--=============================================================================

local Circle = Drawing.new("Circle")
Circle.Color = CONFIG.FOVColor
Circle.Thickness = 2
Circle.Visible = false
Circle.Radius = CONFIG.FOV
Circle.Transparency = 0.7
Circle.Filled = false

--=============================================================================
-- HIT CHANCE & HOOKS
--=============================================================================

local function ShouldHit()
	if CONFIG.HitChance >= 100 then return true end
	if CONFIG.HitChance <= 0 then return false end
	return math.random(1, 100) <= CONFIG.HitChance
end

if not oldNamecall then
	oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
		if not CONFIG.SilentAim or not TargetPart or not CurrentTarget then
			return oldNamecall(self, ...)
		end
		
		local method = getnamecallmethod()
		local args = {...}
		
		if (method == "FireServer" or method == "InvokeServer") and typeof(self) == "Instance" then
			local selfName = self.Name:lower()
			if string.find(selfName, "fire") or string.find(selfName, "hit") or string.find(selfName, "attack") or string.find(selfName, "damage") then
				if not ShouldHit() then return oldNamecall(self, ...) end
				
				local newArgs = {}
				local modified = false
				
				for i, arg in pairs(args) do
					if typeof(arg) == "Vector3" then
						newArgs[i] = TargetPart.Position
						modified = true
					elseif typeof(arg) == "CFrame" then
						newArgs[i] = CFrame.new(TargetPart.Position)
						modified = true
					elseif typeof(arg) == "Ray" then
						local origin = arg.Origin
						newArgs[i] = Ray.new(origin, (TargetPart.Position - origin).Unit * 100)
						modified = true
					else
						newArgs[i] = arg
					end
				end
				
				if modified then return oldNamecall(self, unpack(newArgs)) end
			end
		end
		
		if method == "Raycast" and self == workspace then
			local origin = args[1]
			local direction = args[2]
			
			if origin and TargetPart then
				if not ShouldHit() then return oldNamecall(self, ...) end
				local newDir = (TargetPart.Position - origin).Unit * direction.Magnitude
				return oldNamecall(self, origin, newDir, args[3], args[4])
			end
		end
		
		return oldNamecall(self, ...)
	end)
end

if not oldIndex then
	oldIndex = hookmetamethod(game, "__index", function(self, key)
		if self == Mouse and CONFIG.SilentAim and TargetPart then
			local keyLower = string.lower(key)
			if keyLower == "hit" then
				if not ShouldHit() then return oldIndex(self, key) end
				return CFrame.new(TargetPart.Position)
			elseif keyLower == "target" then
				return TargetPart
			end
		end
		return oldIndex(self, key)
	end)
end

--=============================================================================
-- RENDER LOOP
--=============================================================================

task.spawn(function()
	while true do
		task.wait(CONFIG.UpdateRate)
		if CONFIG.SilentAim then
			CurrentTarget = GetTarget()
		else
			CurrentTarget = nil
			TargetInRange = false
			TargetPart = nil
		end
	end
end)

RunService.RenderStepped:Connect(function()
	Circle.Visible = CONFIG.SilentAim
	if CONFIG.SilentAim then
		local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
		Circle.Position = screenCenter
		Circle.Radius = CONFIG.FOV
		Circle.Color = CONFIG.FOVColor
	end
end)

--=============================================================================
-- PUBLIC API
--=============================================================================

local SilentAimAPI = {}

function SilentAimAPI:UpdateConfig(newConfig)
	for key, value in pairs(newConfig) do
		if CONFIG[key] ~= nil then
			CONFIG[key] = value
		end
	end
end

function SilentAimAPI:GetConfig()
	return CONFIG
end

function SilentAimAPI:Toggle(state)
	CONFIG.SilentAim = state
	if not state then
		CurrentTarget = nil
		TargetInRange = false
		TargetPart = nil
	end
end

function SilentAimAPI:Destroy()
	Circle:Remove()
	CurrentTarget = nil
	TargetPart = nil
end

return SilentAimAPI
